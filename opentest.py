import os
import time
from pathlib import Path
import torch
import torch.nn.functional as F
from PIL import Image
from torchvision import transforms
from tqdm import tqdm
import pandas as pd
import shutil
import json
from collections import defaultdict

from config import CHECKPOINTS, IMG_SIZE, ARTIFACTS
from models.cattle_net import CattleNet
from utils.logger import get_logger

logger = get_logger("retrieval")

# ===================== 参数 =====================
QUERY_DIR   = Path("query")    # ← 替换为真实路径
GALLERY_DIR = Path("gallery")  # ← 替换为真实路径
BATCH_SIZE  = 8
TOP_K       = 5

MANIFEST_PATH = CHECKPOINTS / "manifest.json"
with open(MANIFEST_PATH) as f:
    manifest = json.load(f)
    NUM_CLASSES = manifest['num_classes']

MODEL_PATH     = CHECKPOINTS / manifest["latest_model"]
CLASS_IDX_PATH = CHECKPOINTS / manifest["latest_class_to_idx"]

# ===================== 预处理 =====================
transform = transforms.Compose([
    transforms.Resize((IMG_SIZE, IMG_SIZE)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225]),
])

def load_images_with_labels(folder):
    data = []
    label_counts = defaultdict(int)
    for subfolder in Path(folder).iterdir():
        if subfolder.is_dir():
            label = subfolder.name
            for p in subfolder.glob("*"):
                if p.suffix.lower() in [".jpg", ".jpeg", ".png"]:
                    img = Image.open(p).convert("RGB")
                    tensor = transform(img)
                    data.append((str(p), tensor, label))
                    label_counts[label] += 1
    return data, label_counts

# 全局统计变量
total_feat_time = 0
total_feat_images = 0

@torch.no_grad()
def extract_features_with_stats(model, image_data, label=""):
    global total_feat_time, total_feat_images
    start = time.time()

    paths, tensors, labels = zip(*image_data)
    tensors = torch.stack(tensors).cuda()
    feats = []

    for i in range(0, len(tensors), BATCH_SIZE):
        batch = tensors[i:i+BATCH_SIZE]
        emb = model.extract_features(batch)
        emb = F.normalize(emb, dim=1)
        feats.append(emb.cpu())

    end = time.time()
    elapsed = end - start
    fps = len(image_data) / elapsed

    total_feat_time += elapsed
    total_feat_images += len(image_data)

    print(f"\n️ [{label} 特征提取] 图像数量: {len(image_data)}")
    print(f"️ [{label} 特征提取] 耗时: {elapsed:.2f} 秒")
    print(f" [{label} 特征提取] FPS: {fps:.2f} frames/sec\n")

    return list(paths), torch.cat(feats, dim=0), list(labels)

def compute_topk(query_feats, gallery_feats, topk=1):
    sims = torch.mm(query_feats, gallery_feats.T)
    topk_vals, topk_indices = sims.topk(topk, dim=1)
    return topk_vals, topk_indices

def build_html_output(results, html_path="retrieval_results.html"):
    html = ["<html><body><h1>牛脸检索结果</h1><table border='1'>"]
    for entry in results:
        html.append("<tr>")
        html.append(f"<td><b>Query:<br>{entry['query']}</b><br><img src='{entry['query']}' height='160'></td>")
        for match in entry["matches"]:
            html.append(f"<td><img src='{match['path']}' height='160'><br>Score: {match['score']:.4f}</td>")
        html.append("</tr>")
    html.append("</table></body></html>")
    with open(ARTIFACTS / html_path, "w", encoding="utf-8") as f:
        f.write("\n".join(html))
    logger.info("HTML 结果已保存至 %s", ARTIFACTS / html_path)

def run_retrieval(repeat_times=1):
    logger.info("加载模型")
    model = CattleNet(num_classes=NUM_CLASSES).cuda()
    model.load_state_dict(torch.load(MODEL_PATH))
    model.eval()

    def extract_features_method(self, x):
        feat = self.features(x)
        feat = feat.flatten(1)
        feat = self.embedding(feat)
        return feat
    model.extract_features = extract_features_method.__get__(model)

    logger.info("加载 query 图像")
    query_data, query_label_counts = load_images_with_labels(QUERY_DIR)
    logger.info("加载 gallery 图像")
    gallery_data, gallery_label_counts = load_images_with_labels(GALLERY_DIR)

    if not query_data or not gallery_data:
        logger.error("查询或库图像为空")
        return

    global total_feat_time, total_feat_images
    total_feat_time = 0
    total_feat_images = 0

    for run in range(repeat_times):
        print(f"\n===== 第 {run+1}/{repeat_times} 次执行 =====")
        query_paths, query_feats, query_labels = extract_features_with_stats(model, query_data, label=f"Query#{run+1}")
        gallery_paths, gallery_feats, gallery_labels = extract_features_with_stats(model, gallery_data, label=f"Gallery#{run+1}")

    # 匹配并评估
    logger.info("开始匹配，每个 query 输出 top-%d 结果", TOP_K)
    topk_vals, topk_indices = compute_topk(query_feats, gallery_feats, topk=TOP_K)

    results = []
    csv_records = []
    correct = 0

    for i, (q_path, q_label) in enumerate(zip(query_paths, query_labels)):
        match_entries = []
        hit = False
        for rank, (idx, score) in enumerate(zip(topk_indices[i], topk_vals[i])):
            g_path = gallery_paths[idx]
            g_label = gallery_labels[idx]
            if g_label == q_label:
                hit = True
            match_entries.append({"path": g_path, "score": score.item()})
            csv_records.append({
                "query": q_path,
                "query_label": q_label,
                "rank": rank + 1,
                "match": g_path,
                "match_label": g_label,
                "score": score.item(),
                "hit": g_label == q_label
            })
        if hit:
            correct += 1
        results.append({"query": q_path, "matches": match_entries})

    acc = correct / len(query_paths)
    print(f"\nTop-{TOP_K} 准确率: {acc*100:.2f}% ({correct}/{len(query_paths)})")

    df = pd.DataFrame(csv_records)
    csv_path = ARTIFACTS / "retrieval_results.csv"
    df.to_csv(csv_path, index=False)
    logger.info(" CSV 结果已保存至 %s", csv_path)

    build_html_output(results, "retrieval_results.html")

    print("\n每头牛的图像数量：")
    all_labels = sorted(set(query_label_counts.keys()) | set(gallery_label_counts.keys()))
    for label in all_labels:
        q_num = query_label_counts.get(label, 0)
        g_num = gallery_label_counts.get(label, 0)
        print(f"牛号 {label}: Query {q_num} 张, Gallery {g_num} 张")

    if total_feat_images > 0:
        avg_time_per_image = total_feat_time / total_feat_images
        fps = total_feat_images / total_feat_time
        print(f"\n [特征提取平均统计]")
        print(f"️ 图像总数: {total_feat_images}")
        print(f"️ 总耗时: {total_feat_time:.2f} 秒")
        print(f" 每张图平均耗时: {avg_time_per_image:.4f} 秒")
        print(f" 平均 FPS: {fps:.2f} frames/sec")

if __name__ == "__main__":
    run_retrieval(repeat_times=1)
